!function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=1)}([function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZXMuc2Nzcz9kNDEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/enums/state.js\n/* harmony default export */ var enums_state = ({\n  GAME_OVER: \'GAME_OVER\',\n  GRAVITY: \'GRAVITY\',\n  NEW_GAME: \'NEW_GAME\',\n  PAUSED: \'PAUSED\'\n});\n// CONCATENATED MODULE: ./src/models/renderers/ascii.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nvar UNIT = 50;\n\nvar initCanvas = function initCanvas(id, _ref) {\n  var height = _ref.height,\n      width = _ref.width;\n  var canvas = document.getElementById(id);\n  var ctx = canvas.getContext(\'2d\');\n  canvas.height = UNIT * height;\n  canvas.width = UNIT * width;\n  ctx.font = "".concat(UNIT * 0.8, "px \\"source code pro\\"");\n  ctx.textAlign = \'center\';\n  ctx.textBaseline = \'middle\';\n  return [ctx, canvas];\n};\n\n/* harmony default export */ var ascii = (function (width, height) {\n  var _initCanvas = initCanvas(\'gameBoard\', {\n    height: height,\n    width: width\n  }),\n      _initCanvas2 = _slicedToArray(_initCanvas, 1),\n      gameBoardCtx = _initCanvas2[0];\n\n  var _initCanvas3 = initCanvas(\'text\', {\n    height: height,\n    width: width\n  }),\n      _initCanvas4 = _slicedToArray(_initCanvas3, 2),\n      textCtx = _initCanvas4[0],\n      textCanvas = _initCanvas4[1];\n\n  var displayText = function displayText(text) {\n    var x = width * UNIT / 2 - textCtx.measureText(text).width / 2;\n    var y = height * UNIT / 2;\n    textCanvas.classList.add(\'--visible\');\n    textCtx.textAlign = \'left\';\n    textCtx.clearRect(0, 0, width * UNIT, height * UNIT);\n\n    for (var i = 0; i < text.length; i++) {\n      var c = text.charAt(i);\n      textCtx.fillStyle = /[[\\]]/.test(c) ? \'#C2185B\' : \'white\';\n      textCtx.fillText(c, x, y);\n      x += textCtx.measureText(c).width;\n    }\n  };\n\n  var hideText = function hideText() {\n    textCanvas.classList.remove(\'--visible\');\n  };\n\n  var renderLockedBlocks = function renderLockedBlocks(_ref2) {\n    var fullRowsIndexes = _ref2.fullRowsIndexes,\n        lockedBlocks = _ref2.lockedBlocks;\n    gameBoardCtx.clearRect(0, 0, width * UNIT, height * UNIT);\n\n    for (var y = 0; y < lockedBlocks.length; y++) {\n      for (var x = 0; x < lockedBlocks[y].length; x++) {\n        if (fullRowsIndexes.includes(y)) {\n          gameBoardCtx.fillStyle = \'#C2185B\';\n        } else {\n          gameBoardCtx.fillStyle = lockedBlocks[y][x] ? \'#fff\' : \'rgba(255, 255, 255, .05)\';\n        }\n\n        gameBoardCtx.fillText(lockedBlocks[y][x], x * UNIT + UNIT / 2, y * UNIT + UNIT / 2);\n      }\n    }\n  };\n\n  var renderGhost = function renderGhost(ghost) {\n    if (!ghost) return;\n\n    for (var y = 0; y < ghost.blocks.length; y++) {\n      for (var x = 0; x < ghost.blocks[y].length; x++) {\n        if (!ghost.blocks[y][x]) continue;\n        gameBoardCtx.clearRect(ghost.x * UNIT + x * UNIT, ghost.y * UNIT + y * UNIT, UNIT, UNIT);\n        gameBoardCtx.fillStyle = \'rgba(255, 255, 255, .25)\';\n        gameBoardCtx.fillText(ghost.blocks[y][x], ghost.x * UNIT + x * UNIT + UNIT / 2, ghost.y * UNIT + y * UNIT + UNIT / 2);\n      }\n    }\n  };\n\n  var renderTetrimino = function renderTetrimino(tetrimino) {\n    for (var y = 0; y < tetrimino.blocks.length; y++) {\n      for (var x = 0; x < tetrimino.blocks[y].length; x++) {\n        if (!tetrimino.blocks[y][x]) continue;\n        gameBoardCtx.clearRect((tetrimino.x + x) * UNIT, (tetrimino.y + y) * UNIT, UNIT, UNIT);\n        gameBoardCtx.fillStyle = \'#C2185B\';\n        gameBoardCtx.fillText(tetrimino.blocks[y][x], (tetrimino.x + x) * UNIT + UNIT / 2, (tetrimino.y + y) * UNIT + UNIT / 2);\n      }\n    }\n  };\n\n  return {\n    render: function render(_ref3) {\n      var game = _ref3.game,\n          state = _ref3.name;\n      var fullRowsIndexes = game.fullRowsIndexes,\n          ghost = game.ghost,\n          lockedBlocks = game.lockedBlocks,\n          tetrimino = game.tetrimino;\n      renderLockedBlocks({\n        fullRowsIndexes: fullRowsIndexes,\n        lockedBlocks: lockedBlocks\n      });\n\n      if (tetrimino) {\n        renderGhost(ghost);\n        renderTetrimino(tetrimino);\n      }\n\n      switch (state) {\n        case enums_state.NEW_GAME:\n          displayText(\'Press [Enter]\');\n          break;\n\n        case enums_state.PAUSED:\n          displayText(\'Paused\');\n          break;\n\n        default:\n          hideText();\n      }\n    }\n  };\n});\n// CONCATENATED MODULE: ./node_modules/autobind-decorator/lib/esm/index.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Return a descriptor removing the value and returning a getter\n * The getter will return a .bind version of the function\n * and memoize the result against a symbol on the instance\n */\nfunction boundMethod(target, key, descriptor) {\n  var fn = descriptor.value;\n\n  if (typeof fn !== \'function\') {\n    throw new TypeError("@boundMethod decorator can only be applied to methods not: ".concat(_typeof(fn)));\n  } // In IE11 calling Object.defineProperty has a side-effect of evaluating the\n  // getter for the property which is being replaced. This causes infinite\n  // recursion and an "Out of stack space" error.\n\n\n  var definingProperty = false;\n  return {\n    configurable: true,\n    get: function get() {\n      // eslint-disable-next-line no-prototype-builtins\n      if (definingProperty || this === target.prototype || this.hasOwnProperty(key) || typeof fn !== \'function\') {\n        return fn;\n      }\n\n      var boundFn = fn.bind(this);\n      definingProperty = true;\n      Object.defineProperty(this, key, {\n        configurable: true,\n        get: function get() {\n          return boundFn;\n        },\n        set: function set(value) {\n          fn = value;\n          delete this[key];\n        }\n      });\n      definingProperty = false;\n      return boundFn;\n    },\n    set: function set(value) {\n      fn = value;\n    }\n  };\n}\n/**\n * Use boundMethod to bind all methods on the target.prototype\n */\n\nfunction boundClass(target) {\n  // (Using reflect to get all keys including symbols)\n  var keys; // Use Reflect if exists\n\n  if (typeof Reflect !== \'undefined\' && typeof Reflect.ownKeys === \'function\') {\n    keys = Reflect.ownKeys(target.prototype);\n  } else {\n    keys = Object.getOwnPropertyNames(target.prototype); // Use symbols if support is provided\n\n    if (typeof Object.getOwnPropertySymbols === \'function\') {\n      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\n    }\n  }\n\n  keys.forEach(function (key) {\n    // Ignore special case target method\n    if (key === \'constructor\') {\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key); // Only methods need binding\n\n    if (typeof descriptor.value === \'function\') {\n      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\n    }\n  });\n  return target;\n}\nfunction autobind() {\n  if (arguments.length === 1) {\n    return boundClass.apply(void 0, arguments);\n  }\n\n  return boundMethod.apply(void 0, arguments);\n}\n// CONCATENATED MODULE: ./src/models/core.js\nvar _class;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if (\'value\' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\n\nvar Core = (_class = /*#__PURE__*/function () {\n  function Core(_ref) {\n    var inputsHandler = _ref.inputsHandler,\n        renderer = _ref.renderer,\n        state = _ref.state;\n\n    _classCallCheck(this, Core);\n\n    this.inputsHandler = inputsHandler;\n    this.renderer = renderer;\n    this.state = state;\n  }\n\n  _createClass(Core, [{\n    key: "loop",\n    value: function loop(timestamp) {\n      this.state = this.state.processInput(this.inputsHandler.read()).update(timestamp);\n      this.render(timestamp);\n      window.requestAnimationFrame(this.loop.bind(this));\n    }\n  }, {\n    key: "render",\n    value: function render(timestamp) {\n      this.renderer.render(_objectSpread({}, this.state, {\n        timestamp: timestamp\n      }));\n    }\n  }]);\n\n  return Core;\n}(), (_applyDecoratedDescriptor(_class.prototype, "loop", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "loop"), _class.prototype)), _class);\n\n// CONCATENATED MODULE: ./src/models/chunk.js\nfunction chunk_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction chunk_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { chunk_ownKeys(Object(source), true).forEach(function (key) { chunk_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { chunk_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction chunk_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction chunk_slicedToArray(arr, i) { return chunk_arrayWithHoles(arr) || chunk_iterableToArrayLimit(arr, i) || chunk_unsupportedIterableToArray(arr, i) || chunk_nonIterableRest(); }\n\nfunction chunk_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction chunk_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return chunk_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return chunk_arrayLikeToArray(o, minLen); }\n\nfunction chunk_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction chunk_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction chunk_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction chunk_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction chunk_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction chunk_createClass(Constructor, protoProps, staticProps) { if (protoProps) chunk_defineProperties(Constructor.prototype, protoProps); if (staticProps) chunk_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Chunk = /*#__PURE__*/function () {\n  function Chunk(_ref) {\n    var blocks = _ref.blocks,\n        _ref$x = _ref.x,\n        x = _ref$x === void 0 ? 0 : _ref$x,\n        _ref$y = _ref.y,\n        y = _ref$y === void 0 ? 0 : _ref$y;\n\n    chunk_classCallCheck(this, Chunk);\n\n    this.blocks = blocks;\n    this.x = x;\n    this.y = y;\n  }\n\n  chunk_createClass(Chunk, [{\n    key: "move",\n    value: function move(_ref2) {\n      var _ref3 = chunk_slicedToArray(_ref2, 2),\n          dx = _ref3[0],\n          dy = _ref3[1];\n\n      return new Chunk(chunk_objectSpread({}, this, {\n        x: this.x + dx,\n        y: this.y + dy\n      }));\n    }\n  }]);\n\n  return Chunk;\n}();\n\n\n// CONCATENATED MODULE: ./src/enums/direction.js\n/* harmony default export */ var direction = ({\n  CLOCKWISE: 1,\n  COUNTERCLOCKWISE: -1,\n  DOWN: [0, 1],\n  LEFT: [-1, 0],\n  RIGHT: [1, 0]\n});\n// CONCATENATED MODULE: ./src/models/tetrimino.js\nfunction tetrimino_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { tetrimino_typeof = function _typeof(obj) { return typeof obj; }; } else { tetrimino_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return tetrimino_typeof(obj); }\n\nfunction tetrimino_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction tetrimino_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tetrimino_ownKeys(Object(source), true).forEach(function (key) { tetrimino_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tetrimino_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction tetrimino_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction tetrimino_slicedToArray(arr, i) { return tetrimino_arrayWithHoles(arr) || tetrimino_iterableToArrayLimit(arr, i) || tetrimino_unsupportedIterableToArray(arr, i) || tetrimino_nonIterableRest(); }\n\nfunction tetrimino_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction tetrimino_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return tetrimino_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tetrimino_arrayLikeToArray(o, minLen); }\n\nfunction tetrimino_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction tetrimino_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction tetrimino_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction tetrimino_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction tetrimino_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction tetrimino_createClass(Constructor, protoProps, staticProps) { if (protoProps) tetrimino_defineProperties(Constructor.prototype, protoProps); if (staticProps) tetrimino_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (tetrimino_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n/* .  .  .  .    .  .  4  .    .  .  .  .    .  2  .  .\n   1  2  4  8    .  .  4  .    .  .  .  .    .  2  .  .\n   .  .  .  .    .  .  4  .    1  2  4  8    .  2  .  .\n   .  .  .  .    .  .  4  .    .  .  .  .    .  2  .  .\n     0x00f0        0x4444        0x0f00        0x2222\n\n   1  .  .    .  2  4    .  .  .    .  2  .\n   1  2  4    .  2  .    1  2  4    .  2  .\n   .  .  .    .  2  .    .  .  4    1  2  .\n    0x071      0x226      0x470      0x322\n\n   .  .  4    .  2  .    .  .  .    1  2  .\n   1  2  4    .  2  .    1  2  4    .  2  .\n   .  .  .    .  2  4    1  .  .    .  2  .\n    0x074      0x622      0x170      0x223\n\n   1  2\n   1  2\n   0x33\n\n   .  2  4    .  2  .    .  .  .    1  .  .\n   1  2  .    .  2  4    .  2  4    1  2  .\n   .  .  .    .  .  4    1  2  .    .  2  .\n   .  .  .    .  .  .    .  .  .    .  .  .\n    0x036      0x462      0x360      0x231\n\n   .  2  .    .  2  .    .  .  .    .  2  .\n   1  2  4    .  2  4    1  2  4    1  2  .\n   .  .  .    .  2  .    .  2  .    .  2  .\n    0x072      0x262      0x270      0x232\n\n   1  2  .    .  .  4    .  .  .    .  2  .\n   .  2  4    .  2  4    1  2  .    1  2  .\n   .  .  .    .  2  .    .  2  4    1  .  .\n    0x063      0x264      0x630      0x132  */\n\nvar ENCODED_BLOCKS = [[\'00f0\', \'4444\', \'0f00\', \'2222\'], [\'071\', \'226\', \'470\', \'322\'], [\'074\', \'622\', \'170\', \'223\'], [\'33\'], [\'036\', \'462\', \'360\', \'231\'], [\'072\', \'262\', \'270\', \'232\'], [\'063\', \'264\', \'630\', \'132\']];\nvar BLOCKS = ENCODED_BLOCKS.map(function (encodedBlocks, index) {\n  return encodedBlocks.map(function (encodedBlock) {\n    var blocks = [];\n    var row;\n\n    for (var y = 0; y < encodedBlock.length; y++) {\n      /* eslint-disable no-bitwise */\n      row = parseInt(encodedBlock, 16) >> y * 4 & Math.pow(2, encodedBlock.length) - 1;\n      blocks[y] = [];\n\n      for (var x = 0; x < encodedBlock.length; x++) {\n        blocks[y][x] = row & Math.pow(2, x) ? index + 1 : 0;\n      }\n      /* eslint-enable no-bitwise */\n\n    }\n\n    return blocks;\n  });\n});\nvar SHAPES = \'ijlostz\'.split(\'\');\n\nvar Tetrimino = /*#__PURE__*/function (_Chunk) {\n  _inherits(Tetrimino, _Chunk);\n\n  var _super = _createSuper(Tetrimino);\n\n  function Tetrimino(_ref) {\n    var _this;\n\n    var _ref$rotation = _ref.rotation,\n        rotation = _ref$rotation === void 0 ? 0 : _ref$rotation,\n        shape = _ref.shape,\n        x = _ref.x,\n        y = _ref.y;\n\n    tetrimino_classCallCheck(this, Tetrimino);\n\n    _this = _super.call(this, {\n      blocks: BLOCKS[SHAPES.indexOf(shape)][rotation],\n      x: x,\n      y: y\n    });\n    _this.rotation = rotation;\n    _this.shape = shape;\n    return _this;\n  }\n\n  tetrimino_createClass(Tetrimino, [{\n    key: "move",\n    value: function move(_ref2) {\n      var _ref3 = tetrimino_slicedToArray(_ref2, 2),\n          dx = _ref3[0],\n          dy = _ref3[1];\n\n      return new Tetrimino(tetrimino_objectSpread({}, this, {\n        x: this.x + dx,\n        y: this.y + dy\n      }));\n    }\n  }, {\n    key: "moveTo",\n    value: function moveTo(_ref4) {\n      var _ref5 = tetrimino_slicedToArray(_ref4, 2),\n          x = _ref5[0],\n          y = _ref5[1];\n\n      return new Tetrimino(tetrimino_objectSpread({}, this, {\n        x: x,\n        y: y\n      }));\n    }\n  }, {\n    key: "rotate",\n    value: function rotate(direction) {\n      var rotation = (this.rotation + direction % 4 + 4) % 4;\n      return new Tetrimino(tetrimino_objectSpread({}, this, {\n        blocks: BLOCKS[SHAPES.indexOf(this.shape)][rotation],\n        rotation: rotation\n      }));\n    }\n  }]);\n\n  return Tetrimino;\n}(Chunk);\n\n\n// CONCATENATED MODULE: ./src/models/game.js\nvar game_class;\n\nfunction game_slicedToArray(arr, i) { return game_arrayWithHoles(arr) || game_iterableToArrayLimit(arr, i) || game_unsupportedIterableToArray(arr, i) || game_nonIterableRest(); }\n\nfunction game_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction game_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction game_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction game_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction game_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { game_ownKeys(Object(source), true).forEach(function (key) { game_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { game_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction game_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || game_unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction game_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return game_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return game_arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return game_arrayLikeToArray(arr); }\n\nfunction game_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction game_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction game_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction game_createClass(Constructor, protoProps, staticProps) { if (protoProps) game_defineProperties(Constructor.prototype, protoProps); if (staticProps) game_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction game_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if (\'value\' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\n\n\n\n\nvar I_WALL_KICKS_TABLE = [[[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]], [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]], [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]], [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]]];\nvar JLSTZ_WALL_KICKS_TABLE = [[[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]]];\n\nvar game_createRandomTetrimino = function createRandomTetrimino() {\n  return new Tetrimino({\n    shape: SHAPES[Math.floor(Math.random() * SHAPES.length)]\n  });\n};\n\nvar game_Game = (game_class = /*#__PURE__*/function () {\n  function Game() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$fullRowsIndexes = _ref.fullRowsIndexes,\n        fullRowsIndexes = _ref$fullRowsIndexes === void 0 ? [] : _ref$fullRowsIndexes,\n        _ref$height = _ref.height,\n        height = _ref$height === void 0 ? 20 : _ref$height,\n        lockedBlocks = _ref.lockedBlocks,\n        queue = _ref.queue,\n        _ref$queueSize = _ref.queueSize,\n        queueSize = _ref$queueSize === void 0 ? 3 : _ref$queueSize,\n        tetrimino = _ref.tetrimino,\n        _ref$width = _ref.width,\n        width = _ref$width === void 0 ? 10 : _ref$width;\n\n    game_classCallCheck(this, Game);\n\n    this.fullRowsIndexes = fullRowsIndexes;\n    this.gravity = 1 / 40; // cells per frame at 60 fps (cells per second)\n\n    this.height = lockedBlocks ? lockedBlocks.length : height;\n    this.width = lockedBlocks ? lockedBlocks[0].length : width;\n    this.lockedBlocks = lockedBlocks || _toConsumableArray(new Array(height)).map(function () {\n      return _toConsumableArray(new Array(width)).fill(0);\n    });\n    this.queue = queue !== null && queue !== void 0 ? queue : _toConsumableArray(Array(queueSize)).map(game_createRandomTetrimino);\n    this.tetrimino = tetrimino;\n  }\n\n  game_createClass(Game, [{\n    key: "dropLockedBlocks",\n    value: function dropLockedBlocks() {\n      var fullRowsIndexes = this.fullRowsIndexes.slice();\n      var game = this;\n      var end;\n\n      while (end = fullRowsIndexes.shift()) {\n        var start = fullRowsIndexes[0] || 0;\n        game = game.extractChunks(start, end).reverse().map(game.hardDropChunk).reduce(function (state, chunk) {\n          return state.lockChunk(chunk);\n        }, game);\n      }\n\n      return new Game(game_objectSpread({}, game, {\n        fullRowsIndexes: fullRowsIndexes\n      }));\n    }\n  }, {\n    key: "emptyFullRows",\n    value: function emptyFullRows() {\n      var _this = this;\n\n      var lockedBlocks = this.lockedBlocks.slice();\n      return new Game(game_objectSpread({}, this, {\n        lockedBlocks: lockedBlocks.map(function (row, index) {\n          return _this.fullRowsIndexes.includes(index) ? Array(_this.width).fill(0) : row;\n        })\n      }));\n    }\n  }, {\n    key: "extractChunks",\n    value: function extractChunks(start, end) {\n      var _this2 = this;\n\n      var chunks = [];\n      var chunk;\n\n      var _loop = function _loop(y) {\n        var _loop2 = function _loop2(x) {\n          if (_this2.isEmpty(x, y)) return "continue";\n          chunk = chunks.find(function (chk) {\n            return chk.includes("".concat(x, ",").concat(y)) || chk.includes("".concat(x + 1, ",").concat(y));\n          });\n\n          if (!chunk) {\n            chunks.push([]);\n            chunk = chunks[chunks.length - 1];\n          }\n\n          if (!_this2.isEmpty(x + 1, y) && !chunk.includes("".concat(x + 1, ",").concat(y))) {\n            chunk.push("".concat(x + 1, ",").concat(y));\n          }\n\n          if (!_this2.isEmpty(x, y + 1) && !chunk.includes("".concat(x, ",").concat(y + 1))) {\n            chunk.push("".concat(x, ",").concat(y + 1));\n          }\n\n          if (!chunk.includes("".concat(x, ",").concat(y))) chunk.push("".concat(x, ",").concat(y));\n        };\n\n        for (var x = 0; x < _this2.width; x++) {\n          var _ret = _loop2(x);\n\n          if (_ret === "continue") continue;\n        }\n      };\n\n      for (var y = start; y < end; y++) {\n        _loop(y);\n      }\n\n      return chunks.map(function (strings) {\n        var coordinates = strings.map(function (string) {\n          return string.split(\',\');\n        });\n        var xMax = Math.max.apply(Math, _toConsumableArray(coordinates.map(function (_ref2) {\n          var _ref3 = game_slicedToArray(_ref2, 1),\n              x = _ref3[0];\n\n          return x;\n        })));\n        var xMin = Math.min.apply(Math, _toConsumableArray(coordinates.map(function (_ref4) {\n          var _ref5 = game_slicedToArray(_ref4, 1),\n              x = _ref5[0];\n\n          return x;\n        })));\n        var yMax = Math.max.apply(Math, _toConsumableArray(coordinates.map(function (_ref6) {\n          var _ref7 = game_slicedToArray(_ref6, 2),\n              y = _ref7[1];\n\n          return y;\n        })));\n        var yMin = Math.min.apply(Math, _toConsumableArray(coordinates.map(function (_ref8) {\n          var _ref9 = game_slicedToArray(_ref8, 2),\n              y = _ref9[1];\n\n          return y;\n        })));\n\n        var blocks = _toConsumableArray(Array(yMax - yMin + 1)).map(function () {\n          return Array(xMax - xMin + 1).fill(0);\n        });\n\n        coordinates.forEach(function (_ref10) {\n          var _ref11 = game_slicedToArray(_ref10, 2),\n              x = _ref11[0],\n              y = _ref11[1];\n\n          blocks[y - yMin][x - xMin] = _this2.lockedBlocks[y][x];\n          _this2.lockedBlocks[y][x] = 0; // @todo: do not mutate lockedBlocks\n        });\n        return new Chunk({\n          blocks: blocks,\n          x: xMin,\n          y: yMin\n        });\n      });\n    }\n  }, {\n    key: "hardDropChunk",\n    value: function hardDropChunk(chunk) {\n      var next = chunk;\n\n      while (this.isValidChunk(next.move(direction.DOWN))) {\n        next = next.move(direction.DOWN);\n      }\n\n      return next;\n    }\n  }, {\n    key: "hardDropTetrimino",\n    value: function hardDropTetrimino() {\n      return new Game(game_objectSpread({}, this, {\n        tetrimino: this.ghost\n      }));\n    }\n  }, {\n    key: "isEmpty",\n    value: function isEmpty(x, y) {\n      return this.lockedBlocks[y] && !this.lockedBlocks[y][x];\n    }\n  }, {\n    key: "isOutOfBounds",\n    value: function isOutOfBounds(x, y) {\n      return x < 0 || x >= this.width || y < 0 || y >= this.height;\n    }\n  }, {\n    key: "isValidChunk",\n    value: function isValidChunk(chunk) {\n      var _this3 = this;\n\n      return chunk.blocks.every(function (row, y) {\n        return row.every(function (block, x) {\n          return !chunk.blocks[y][x] || _this3.isEmpty(chunk.x + x, chunk.y + y) && !_this3.isOutOfBounds(chunk.x + x, chunk.y + y);\n        });\n      });\n    }\n  }, {\n    key: "lockChunk",\n    value: function lockChunk(chunk) {\n      var lockedBlocks = this.lockedBlocks.slice();\n      chunk.blocks.forEach(function (row, y) {\n        return row.forEach(function (block, x) {\n          if (!block) return;\n          lockedBlocks[chunk.y + y][chunk.x + x] = block;\n        });\n      });\n      return new Game(game_objectSpread({}, this, {\n        lockedBlocks: lockedBlocks\n      }));\n    }\n  }, {\n    key: "lockTetrimino",\n    value: function lockTetrimino() {\n      return new Game(game_objectSpread({}, this.lockChunk(this.tetrimino), {\n        tetrimino: null\n      }));\n    }\n  }, {\n    key: "markFullRows",\n    value: function markFullRows() {\n      return new Game(game_objectSpread({}, this, {\n        fullRowsIndexes: this.lockedBlocks.reduce(function (fullRows, row, index) {\n          return row.every(function (block) {\n            return block;\n          }) ? fullRows.concat(index) : fullRows;\n        }, []).reverse()\n      }));\n    }\n  }, {\n    key: "moveTetrimino",\n    value: function moveTetrimino(_ref12) {\n      var _ref13 = game_slicedToArray(_ref12, 2),\n          x = _ref13[0],\n          y = _ref13[1];\n\n      var next = this.tetrimino.move([x, y]);\n      if (!this.isValidChunk(next)) return this;\n      return new Game(game_objectSpread({}, this, {\n        tetrimino: next\n      }));\n    }\n  }, {\n    key: "reset",\n    value: function reset() {\n      return new Game({\n        height: this.height,\n        width: this.width\n      });\n    }\n  }, {\n    key: "rotateTetrimino",\n    value: function rotateTetrimino(angle) {\n      if (this.tetrimino.shape === \'o\') return this;\n      var next = this.tetrimino;\n      var index = angle === direction.CLOCKWISE ? next.rotation : next.rotate(angle).rotation;\n      var wallKicks = next.shape === \'i\' ? I_WALL_KICKS_TABLE[index] : JLSTZ_WALL_KICKS_TABLE[index];\n      var i = 0;\n\n      do {\n        var _wallKicks$i = game_slicedToArray(wallKicks[i], 2),\n            x = _wallKicks$i[0],\n            y = _wallKicks$i[1];\n\n        next = this.tetrimino.rotate(angle).move([x * angle, y * angle]);\n      } while (!this.isValidChunk(next) && wallKicks[++i]);\n\n      return i < wallKicks.length ? new Game(game_objectSpread({}, this, {\n        tetrimino: next\n      })) : this;\n    }\n  }, {\n    key: "shiftQueue",\n    value: function shiftQueue() {\n      var queue = this.queue.slice();\n      queue.push(game_createRandomTetrimino());\n      var tetrimino = queue.shift();\n      tetrimino = tetrimino.moveTo([Math.floor((this.width - tetrimino.blocks.length) / 2), 0]);\n      return new Game(game_objectSpread({}, this, {\n        queue: queue,\n        tetrimino: tetrimino\n      }));\n    }\n  }, {\n    key: "ghost",\n    get: function get() {\n      if (!this.tetrimino) return null;\n      return this.hardDropChunk(this.tetrimino);\n    }\n  }]);\n\n  return Game;\n}(), (game_applyDecoratedDescriptor(game_class.prototype, "hardDropChunk", [autobind], Object.getOwnPropertyDescriptor(game_class.prototype, "hardDropChunk"), game_class.prototype)), game_class);\n\n// CONCATENATED MODULE: ./src/models/inputs-handler.js\nvar inputs_handler_class;\n\nfunction inputs_handler_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction inputs_handler_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction inputs_handler_createClass(Constructor, protoProps, staticProps) { if (protoProps) inputs_handler_defineProperties(Constructor.prototype, protoProps); if (staticProps) inputs_handler_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction inputs_handler_applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if (\'value\' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\n\nvar InputsHandler = (inputs_handler_class = /*#__PURE__*/function () {\n  function InputsHandler(domNode) {\n    inputs_handler_classCallCheck(this, InputsHandler);\n\n    this.inputs = [];\n    domNode.addEventListener(\'keydown\', this.handleKeyDown);\n  }\n\n  inputs_handler_createClass(InputsHandler, [{\n    key: "handleKeyDown",\n    value: function handleKeyDown(event) {\n      this.inputs.push(event.code);\n    }\n  }, {\n    key: "read",\n    value: function read() {\n      return this.inputs.shift();\n    }\n  }]);\n\n  return InputsHandler;\n}(), (inputs_handler_applyDecoratedDescriptor(inputs_handler_class.prototype, "handleKeyDown", [autobind], Object.getOwnPropertyDescriptor(inputs_handler_class.prototype, "handleKeyDown"), inputs_handler_class.prototype)), inputs_handler_class);\n\n// CONCATENATED MODULE: ./src/enums/key.js\n// https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n/* harmony default export */ var key = ({\n  A: \'KeyA\',\n  CTRL_LEFT: \'ControlLeft\',\n  CTRL_RIGHT: \'ControlRight\',\n  D: \'KeyD\',\n  DOWN_ARROW: \'ArrowDown\',\n  ENTER: \'Enter\',\n  ESCAPE: \'Escape\',\n  F1: \'F1\',\n  LEFT_ARROW: \'ArrowLeft\',\n  RIGHT_ARROW: \'ArrowRight\',\n  S: \'KeyS\',\n  SPACE: \'Space\',\n  UP_ARROW: \'ArrowUp\',\n  X: \'KeyX\',\n  Z: \'KeyZ\'\n});\n// CONCATENATED MODULE: ./src/models/states/paused.js\nfunction paused_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction paused_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { paused_ownKeys(Object(source), true).forEach(function (key) { paused_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { paused_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction paused_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction paused_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction paused_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction paused_createClass(Constructor, protoProps, staticProps) { if (protoProps) paused_defineProperties(Constructor.prototype, protoProps); if (staticProps) paused_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar paused_PausedState = /*#__PURE__*/function () {\n  function PausedState(_ref) {\n    var game = _ref.game;\n\n    paused_classCallCheck(this, PausedState);\n\n    this.game = game;\n    this.name = enums_state.PAUSED;\n  }\n\n  paused_createClass(PausedState, [{\n    key: "processInput",\n    value: function processInput(input) {\n      switch (input) {\n        case key.ESCAPE:\n        case key.F1:\n          return new gravity_GravityState(paused_objectSpread({}, this, {\n            lastUpdatedAt: this.timestamp,\n            startedAt: this.timestamp\n          }));\n\n        default:\n          return this;\n      }\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      return this;\n    }\n  }]);\n\n  return PausedState;\n}();\n\n\n// CONCATENATED MODULE: ./src/models/states/rows-clearing.js\nfunction rows_clearing_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction rows_clearing_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rows_clearing_ownKeys(Object(source), true).forEach(function (key) { rows_clearing_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rows_clearing_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction rows_clearing_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction rows_clearing_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rows_clearing_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rows_clearing_createClass(Constructor, protoProps, staticProps) { if (protoProps) rows_clearing_defineProperties(Constructor.prototype, protoProps); if (staticProps) rows_clearing_defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar CLEAR_DURATION = 500;\n\nvar rows_clearing_RowsClearingState = /*#__PURE__*/function () {\n  function RowsClearingState(_ref) {\n    var game = _ref.game,\n        _ref$startsAt = _ref.startsAt,\n        startsAt = _ref$startsAt === void 0 ? 0 : _ref$startsAt;\n\n    rows_clearing_classCallCheck(this, RowsClearingState);\n\n    this.game = game;\n    this.startsAt = startsAt;\n  }\n\n  rows_clearing_createClass(RowsClearingState, [{\n    key: "processInput",\n    value: function processInput() {\n      return this;\n    }\n  }, {\n    key: "update",\n    value: function update(timestamp) {\n      var game = this.game;\n      game = game.markFullRows();\n\n      if (game.fullRowsIndexes.length) {\n        if (!this.startsAt) {\n          this.startsAt = timestamp;\n          return new RowsClearingState(rows_clearing_objectSpread({}, this, {\n            game: game\n          }));\n        }\n\n        if (timestamp < this.startsAt + CLEAR_DURATION) return this;\n        game = game.emptyFullRows().dropLockedBlocks();\n        return new RowsClearingState({\n          game: game\n        });\n      }\n\n      return new gravity_GravityState(rows_clearing_objectSpread({}, this, {\n        game: game\n      }));\n    }\n  }]);\n\n  return RowsClearingState;\n}();\n\n\n// CONCATENATED MODULE: ./src/models/states/gravity.js\nfunction gravity_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction gravity_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { gravity_ownKeys(Object(source), true).forEach(function (key) { gravity_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { gravity_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction gravity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction gravity_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction gravity_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction gravity_createClass(Constructor, protoProps, staticProps) { if (protoProps) gravity_defineProperties(Constructor.prototype, protoProps); if (staticProps) gravity_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\nvar FRAME_LENGTH_AT_60_FPS = 1000 / 60;\nvar LOCK_DELAY = 500;\n\nvar gravity_GravityState = /*#__PURE__*/function () {\n  function GravityState(_ref) {\n    var game = _ref.game,\n        lastUpdatedAt = _ref.lastUpdatedAt,\n        lockExpiry = _ref.lockExpiry,\n        movesLeft = _ref.movesLeft,\n        startedAt = _ref.startedAt;\n\n    gravity_classCallCheck(this, GravityState);\n\n    this.game = game;\n    this.lastUpdatedAt = lastUpdatedAt || 0;\n    this.lockExpiry = lockExpiry || 0;\n    this.movesLeft = movesLeft || 0;\n    this.name = enums_state.GRAVITY;\n    this.startedAt = startedAt || 0;\n  }\n\n  gravity_createClass(GravityState, [{\n    key: "applyGravity",\n    value: function applyGravity(game) {\n      var lastUpdatedAt = this.lastUpdatedAt,\n          startedAt = this.startedAt,\n          timestamp = this.timestamp;\n      var dt = timestamp - startedAt - lastUpdatedAt;\n      var dy = Math.floor(dt * game.gravity / FRAME_LENGTH_AT_60_FPS);\n      if (dy) this.lastUpdatedAt = timestamp - startedAt;\n      return game.moveTetrimino([0, dy]);\n    }\n  }, {\n    key: "hardDropTetrimino",\n    value: function hardDropTetrimino() {\n      var game = this.game;\n      return new rows_clearing_RowsClearingState(gravity_objectSpread({}, this, {\n        game: game.hardDropTetrimino().lockTetrimino()\n      }));\n    }\n  }, {\n    key: "moveTetrimino",\n    value: function moveTetrimino(direction) {\n      var game = this.game,\n          lockExpiry = this.lockExpiry,\n          timestamp = this.timestamp;\n      var next = game.moveTetrimino(direction);\n      if (next === game) return this;\n\n      if (lockExpiry) {\n        this.lockExpiry = timestamp + LOCK_DELAY;\n        --this.movesLeft;\n      }\n\n      return new GravityState(gravity_objectSpread({}, this, {\n        game: next\n      }));\n    }\n  }, {\n    key: "processInput",\n    value: function processInput(input) {\n      if (!this.game.tetrimino) return this;\n\n      switch (input) {\n        case key.CTRL_LEFT:\n        case key.CTRL_RIGHT:\n        case key.Z:\n          return this.rotateTetrimino(direction.COUNTERCLOCKWISE);\n\n        case key.DOWN_ARROW:\n        case key.S:\n          return this.moveTetrimino(direction.DOWN);\n\n        case key.ESCAPE:\n        case key.F1:\n          return new paused_PausedState(this);\n\n        case key.LEFT_ARROW:\n        case key.A:\n          return this.moveTetrimino(direction.LEFT);\n\n        case key.RIGHT_ARROW:\n        case key.D:\n          return this.moveTetrimino(direction.RIGHT);\n\n        case key.SPACE:\n          return this.hardDropTetrimino();\n\n        case key.UP_ARROW:\n        case key.X:\n          return this.rotateTetrimino(direction.CLOCKWISE);\n\n        default:\n          return this;\n      }\n    }\n  }, {\n    key: "rotateTetrimino",\n    value: function rotateTetrimino(direction) {\n      var game = this.game,\n          lockExpiry = this.lockExpiry,\n          timestamp = this.timestamp;\n      var next = game.rotateTetrimino(direction);\n      if (next === this.game) return this;\n\n      if (lockExpiry) {\n        this.lockExpiry = timestamp + LOCK_DELAY;\n        --this.movesLeft;\n      }\n\n      return new GravityState(gravity_objectSpread({}, this, {\n        game: next\n      }));\n    }\n  }, {\n    key: "update",\n    value: function update(timestamp) {\n      var game = this.game;\n      this.timestamp = timestamp;\n      if (!this.startedAt) this.startedAt = timestamp;\n      if (!game.tetrimino) game = game.shiftQueue();\n\n      if (!game.isValidChunk(game.tetrimino)) {\n        return new new_game_NewGameState({\n          game: game.reset()\n        });\n      }\n\n      game = this.applyGravity(game);\n\n      if (game.isValidChunk(game.tetrimino.move(direction.DOWN))) {\n        return new GravityState(gravity_objectSpread({}, this, {\n          game: game,\n          lockExpiry: 0\n        }));\n      } else if (!this.lockExpiry) {\n        return new GravityState(gravity_objectSpread({}, this, {\n          game: game,\n          lockExpiry: timestamp + LOCK_DELAY,\n          movesLeft: 15\n        }));\n      } else if (timestamp > this.lockExpiry || !this.movesLeft) {\n        return new rows_clearing_RowsClearingState(gravity_objectSpread({}, this, {\n          game: game.lockTetrimino()\n        }));\n      }\n\n      return this;\n    }\n  }]);\n\n  return GravityState;\n}();\n\n\n// CONCATENATED MODULE: ./src/models/states/new-game.js\nfunction new_game_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction new_game_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction new_game_createClass(Constructor, protoProps, staticProps) { if (protoProps) new_game_defineProperties(Constructor.prototype, protoProps); if (staticProps) new_game_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar new_game_NewGameState = /*#__PURE__*/function () {\n  function NewGameState(_ref) {\n    var game = _ref.game;\n\n    new_game_classCallCheck(this, NewGameState);\n\n    this.game = game;\n    this.name = enums_state.NEW_GAME;\n  }\n\n  new_game_createClass(NewGameState, [{\n    key: "processInput",\n    value: function processInput(input) {\n      switch (input) {\n        case key.ENTER:\n          return new gravity_GravityState(this);\n\n        default:\n          return this;\n      }\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      return this;\n    }\n  }]);\n\n  return NewGameState;\n}();\n\n\n// EXTERNAL MODULE: ./src/styles.scss\nvar styles = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\nvar inputsHandler = new InputsHandler(document.body);\nvar src_game = new game_Game();\nvar renderer = ascii(src_game.width, src_game.height);\nvar src_state = new new_game_NewGameState({\n  game: src_game\n});\nvar core = new Core({\n  inputsHandler: inputsHandler,\n  renderer: renderer,\n  state: src_state\n});\ncore.loop();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9lbnVtcy9zdGF0ZS5qcz84YmI5Iiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvcmVuZGVyZXJzL2FzY2lpLmpzPzA1YjMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F1dG9iaW5kLWRlY29yYXRvci9saWIvZXNtL2luZGV4LmpzP2JhY2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9jb3JlLmpzP2Y4M2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9jaHVuay5qcz8xMTRjIiwid2VicGFjazovLy8uL3NyYy9lbnVtcy9kaXJlY3Rpb24uanM/NDllNyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL3RldHJpbWluby5qcz80NzQ5Iiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvZ2FtZS5qcz84ZmI4Iiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvaW5wdXRzLWhhbmRsZXIuanM/YmEwMyIsIndlYnBhY2s6Ly8vLi9zcmMvZW51bXMva2V5LmpzP2RlMDciLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9zdGF0ZXMvcGF1c2VkLmpzP2NiMGIiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9zdGF0ZXMvcm93cy1jbGVhcmluZy5qcz85MDRiIiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvc3RhdGVzL2dyYXZpdHkuanM/NzFjZSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL3N0YXRlcy9uZXctZ2FtZS5qcz81Y2I1Iiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcbiAgR0FNRV9PVkVSOiAnR0FNRV9PVkVSJyxcbiAgR1JBVklUWTogJ0dSQVZJVFknLFxuICBORVdfR0FNRTogJ05FV19HQU1FJyxcbiAgUEFVU0VEOiAnUEFVU0VEJyxcbn07XG4iLCJpbXBvcnQgU3RhdGUgZnJvbSAnZW51bXMvc3RhdGUnO1xuXG5jb25zdCBVTklUID0gNTA7XG5cbmNvbnN0IGluaXRDYW52YXMgPSAoaWQsIHsgaGVpZ2h0LCB3aWR0aCB9KSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgY2FudmFzLmhlaWdodCA9IFVOSVQgKiBoZWlnaHQ7XG4gIGNhbnZhcy53aWR0aCA9IFVOSVQgKiB3aWR0aDtcbiAgY3R4LmZvbnQgPSBgJHtVTklUICogMC44fXB4IFwic291cmNlIGNvZGUgcHJvXCJgO1xuICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgcmV0dXJuIFtjdHgsIGNhbnZhc107XG59O1xuXG5leHBvcnQgZGVmYXVsdCAod2lkdGgsIGhlaWdodCkgPT4ge1xuICBjb25zdCBbZ2FtZUJvYXJkQ3R4XSA9IGluaXRDYW52YXMoJ2dhbWVCb2FyZCcsIHsgaGVpZ2h0LCB3aWR0aCB9KTtcbiAgY29uc3QgW3RleHRDdHgsIHRleHRDYW52YXNdID0gaW5pdENhbnZhcygndGV4dCcsIHsgaGVpZ2h0LCB3aWR0aCB9KTtcblxuICBjb25zdCBkaXNwbGF5VGV4dCA9IHRleHQgPT4ge1xuICAgIGxldCB4ID0gd2lkdGggKiBVTklUIC8gMiAtIHRleHRDdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGggLyAyO1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgKiBVTklUIC8gMjtcblxuICAgIHRleHRDYW52YXMuY2xhc3NMaXN0LmFkZCgnLS12aXNpYmxlJyk7XG4gICAgdGV4dEN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgdGV4dEN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGggKiBVTklULCBoZWlnaHQgKiBVTklUKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgICAgdGV4dEN0eC5maWxsU3R5bGUgPSAvW1tcXF1dLy50ZXN0KGMpID8gJyNDMjE4NUInIDogJ3doaXRlJztcbiAgICAgIHRleHRDdHguZmlsbFRleHQoYywgeCwgeSk7XG4gICAgICB4ICs9IHRleHRDdHgubWVhc3VyZVRleHQoYykud2lkdGg7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhpZGVUZXh0ID0gKCkgPT4ge1xuICAgIHRleHRDYW52YXMuY2xhc3NMaXN0LnJlbW92ZSgnLS12aXNpYmxlJyk7XG4gIH07XG5cbiAgY29uc3QgcmVuZGVyTG9ja2VkQmxvY2tzID0gKHsgZnVsbFJvd3NJbmRleGVzLCBsb2NrZWRCbG9ja3MgfSkgPT4ge1xuICAgIGdhbWVCb2FyZEN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGggKiBVTklULCBoZWlnaHQgKiBVTklUKTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGxvY2tlZEJsb2Nrcy5sZW5ndGg7IHkrKykge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBsb2NrZWRCbG9ja3NbeV0ubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgaWYgKGZ1bGxSb3dzSW5kZXhlcy5pbmNsdWRlcyh5KSkge1xuICAgICAgICAgIGdhbWVCb2FyZEN0eC5maWxsU3R5bGUgPSAnI0MyMTg1Qic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2FtZUJvYXJkQ3R4LmZpbGxTdHlsZSA9IGxvY2tlZEJsb2Nrc1t5XVt4XVxuICAgICAgICAgICAgPyAnI2ZmZidcbiAgICAgICAgICAgIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgLjA1KSc7XG4gICAgICAgIH1cbiAgICAgICAgZ2FtZUJvYXJkQ3R4LmZpbGxUZXh0KFxuICAgICAgICAgIGxvY2tlZEJsb2Nrc1t5XVt4XSxcbiAgICAgICAgICB4ICogVU5JVCArIFVOSVQgLyAyLFxuICAgICAgICAgIHkgKiBVTklUICsgVU5JVCAvIDIsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlbmRlckdob3N0ID0gZ2hvc3QgPT4ge1xuICAgIGlmICghZ2hvc3QpIHJldHVybjtcblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgZ2hvc3QuYmxvY2tzLmxlbmd0aDsgeSsrKSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGdob3N0LmJsb2Nrc1t5XS5sZW5ndGg7IHgrKykge1xuICAgICAgICBpZiAoIWdob3N0LmJsb2Nrc1t5XVt4XSkgY29udGludWU7XG5cbiAgICAgICAgZ2FtZUJvYXJkQ3R4LmNsZWFyUmVjdChcbiAgICAgICAgICBnaG9zdC54ICogVU5JVCArIHggKiBVTklULFxuICAgICAgICAgIGdob3N0LnkgKiBVTklUICsgeSAqIFVOSVQsXG4gICAgICAgICAgVU5JVCxcbiAgICAgICAgICBVTklULFxuICAgICAgICApO1xuICAgICAgICBnYW1lQm9hcmRDdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgLjI1KSc7XG4gICAgICAgIGdhbWVCb2FyZEN0eC5maWxsVGV4dChcbiAgICAgICAgICBnaG9zdC5ibG9ja3NbeV1beF0sXG4gICAgICAgICAgZ2hvc3QueCAqIFVOSVQgKyB4ICogVU5JVCArIFVOSVQgLyAyLFxuICAgICAgICAgIGdob3N0LnkgKiBVTklUICsgeSAqIFVOSVQgKyBVTklUIC8gMixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVuZGVyVGV0cmltaW5vID0gdGV0cmltaW5vID0+IHtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRldHJpbWluby5ibG9ja3MubGVuZ3RoOyB5KyspIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGV0cmltaW5vLmJsb2Nrc1t5XS5sZW5ndGg7IHgrKykge1xuICAgICAgICBpZiAoIXRldHJpbWluby5ibG9ja3NbeV1beF0pIGNvbnRpbnVlO1xuXG4gICAgICAgIGdhbWVCb2FyZEN0eC5jbGVhclJlY3QoXG4gICAgICAgICAgKHRldHJpbWluby54ICsgeCkgKiBVTklULFxuICAgICAgICAgICh0ZXRyaW1pbm8ueSArIHkpICogVU5JVCxcbiAgICAgICAgICBVTklULFxuICAgICAgICAgIFVOSVQsXG4gICAgICAgICk7XG4gICAgICAgIGdhbWVCb2FyZEN0eC5maWxsU3R5bGUgPSAnI0MyMTg1Qic7XG4gICAgICAgIGdhbWVCb2FyZEN0eC5maWxsVGV4dChcbiAgICAgICAgICB0ZXRyaW1pbm8uYmxvY2tzW3ldW3hdLFxuICAgICAgICAgICh0ZXRyaW1pbm8ueCArIHgpICogVU5JVCArIFVOSVQgLyAyLFxuICAgICAgICAgICh0ZXRyaW1pbm8ueSArIHkpICogVU5JVCArIFVOSVQgLyAyLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHJlbmRlcih7IGdhbWUsIG5hbWU6IHN0YXRlIH0pIHtcbiAgICAgIGNvbnN0IHsgZnVsbFJvd3NJbmRleGVzLCBnaG9zdCwgbG9ja2VkQmxvY2tzLCB0ZXRyaW1pbm8gfSA9IGdhbWU7XG5cbiAgICAgIHJlbmRlckxvY2tlZEJsb2Nrcyh7IGZ1bGxSb3dzSW5kZXhlcywgbG9ja2VkQmxvY2tzIH0pO1xuXG4gICAgICBpZiAodGV0cmltaW5vKSB7XG4gICAgICAgIHJlbmRlckdob3N0KGdob3N0KTtcbiAgICAgICAgcmVuZGVyVGV0cmltaW5vKHRldHJpbWlubyk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuTkVXX0dBTUU6IGRpc3BsYXlUZXh0KCdQcmVzcyBbRW50ZXJdJyk7IGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5QQVVTRUQ6IGRpc3BsYXlUZXh0KCdQYXVzZWQnKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBoaWRlVGV4dCgpO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG59O1xuIiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBSZXR1cm4gYSBkZXNjcmlwdG9yIHJlbW92aW5nIHRoZSB2YWx1ZSBhbmQgcmV0dXJuaW5nIGEgZ2V0dGVyXG4gKiBUaGUgZ2V0dGVyIHdpbGwgcmV0dXJuIGEgLmJpbmQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb25cbiAqIGFuZCBtZW1vaXplIHRoZSByZXN1bHQgYWdhaW5zdCBhIHN5bWJvbCBvbiB0aGUgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5kTWV0aG9kKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIHZhciBmbiA9IGRlc2NyaXB0b3IudmFsdWU7XG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAYm91bmRNZXRob2QgZGVjb3JhdG9yIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gbWV0aG9kcyBub3Q6IFwiLmNvbmNhdChfdHlwZW9mKGZuKSkpO1xuICB9IC8vIEluIElFMTEgY2FsbGluZyBPYmplY3QuZGVmaW5lUHJvcGVydHkgaGFzIGEgc2lkZS1lZmZlY3Qgb2YgZXZhbHVhdGluZyB0aGVcbiAgLy8gZ2V0dGVyIGZvciB0aGUgcHJvcGVydHkgd2hpY2ggaXMgYmVpbmcgcmVwbGFjZWQuIFRoaXMgY2F1c2VzIGluZmluaXRlXG4gIC8vIHJlY3Vyc2lvbiBhbmQgYW4gXCJPdXQgb2Ygc3RhY2sgc3BhY2VcIiBlcnJvci5cblxuXG4gIHZhciBkZWZpbmluZ1Byb3BlcnR5ID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgaWYgKGRlZmluaW5nUHJvcGVydHkgfHwgdGhpcyA9PT0gdGFyZ2V0LnByb3RvdHlwZSB8fCB0aGlzLmhhc093blByb3BlcnR5KGtleSkgfHwgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdW5kRm4gPSBmbi5iaW5kKHRoaXMpO1xuICAgICAgZGVmaW5pbmdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGJvdW5kRm47XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgZm4gPSB2YWx1ZTtcbiAgICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRlZmluaW5nUHJvcGVydHkgPSBmYWxzZTtcbiAgICAgIHJldHVybiBib3VuZEZuO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGZuID0gdmFsdWU7XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBVc2UgYm91bmRNZXRob2QgdG8gYmluZCBhbGwgbWV0aG9kcyBvbiB0aGUgdGFyZ2V0LnByb3RvdHlwZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBib3VuZENsYXNzKHRhcmdldCkge1xuICAvLyAoVXNpbmcgcmVmbGVjdCB0byBnZXQgYWxsIGtleXMgaW5jbHVkaW5nIHN5bWJvbHMpXG4gIHZhciBrZXlzOyAvLyBVc2UgUmVmbGVjdCBpZiBleGlzdHNcblxuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBSZWZsZWN0Lm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBrZXlzID0gUmVmbGVjdC5vd25LZXlzKHRhcmdldC5wcm90b3R5cGUpO1xuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQucHJvdG90eXBlKTsgLy8gVXNlIHN5bWJvbHMgaWYgc3VwcG9ydCBpcyBwcm92aWRlZFxuXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQucHJvdG90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAvLyBJZ25vcmUgc3BlY2lhbCBjYXNlIHRhcmdldCBtZXRob2RcbiAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5wcm90b3R5cGUsIGtleSk7IC8vIE9ubHkgbWV0aG9kcyBuZWVkIGJpbmRpbmdcblxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldC5wcm90b3R5cGUsIGtleSwgYm91bmRNZXRob2QodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b2JpbmQoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGJvdW5kQ2xhc3MuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kTWV0aG9kLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbn0iLCJpbXBvcnQgYXV0b2JpbmQgZnJvbSAnYXV0b2JpbmQtZGVjb3JhdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZSB7XG4gIGNvbnN0cnVjdG9yKHsgaW5wdXRzSGFuZGxlciwgcmVuZGVyZXIsIHN0YXRlIH0pIHtcbiAgICB0aGlzLmlucHV0c0hhbmRsZXIgPSBpbnB1dHNIYW5kbGVyO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgbG9vcCh0aW1lc3RhbXApIHtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZVxuICAgICAgLnByb2Nlc3NJbnB1dCh0aGlzLmlucHV0c0hhbmRsZXIucmVhZCgpKVxuICAgICAgLnVwZGF0ZSh0aW1lc3RhbXApO1xuICAgIHRoaXMucmVuZGVyKHRpbWVzdGFtcCk7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmxvb3AuYmluZCh0aGlzKSk7XG4gIH1cblxuICByZW5kZXIodGltZXN0YW1wKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIoeyAuLi50aGlzLnN0YXRlLCB0aW1lc3RhbXAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIENodW5rIHtcbiAgY29uc3RydWN0b3IoeyBibG9ja3MsIHggPSAwLCB5ID0gMCB9KSB7XG4gICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgbW92ZShbZHgsIGR5XSkge1xuICAgIHJldHVybiBuZXcgQ2h1bmsoeyAuLi50aGlzLCB4OiB0aGlzLnggKyBkeCwgeTogdGhpcy55ICsgZHkgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgQ0xPQ0tXSVNFOiAxLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAtMSxcbiAgRE9XTjogWzAsIDFdLFxuICBMRUZUOiBbLTEsIDBdLFxuICBSSUdIVDogWzEsIDBdLFxufTtcbiIsImltcG9ydCBDaHVuayBmcm9tICdtb2RlbHMvY2h1bmsnO1xuXG4vKiAuICAuICAuICAuICAgIC4gIC4gIDQgIC4gICAgLiAgLiAgLiAgLiAgICAuICAyICAuICAuXG4gICAxICAyICA0ICA4ICAgIC4gIC4gIDQgIC4gICAgLiAgLiAgLiAgLiAgICAuICAyICAuICAuXG4gICAuICAuICAuICAuICAgIC4gIC4gIDQgIC4gICAgMSAgMiAgNCAgOCAgICAuICAyICAuICAuXG4gICAuICAuICAuICAuICAgIC4gIC4gIDQgIC4gICAgLiAgLiAgLiAgLiAgICAuICAyICAuICAuXG4gICAgIDB4MDBmMCAgICAgICAgMHg0NDQ0ICAgICAgICAweDBmMDAgICAgICAgIDB4MjIyMlxuXG4gICAxICAuICAuICAgIC4gIDIgIDQgICAgLiAgLiAgLiAgICAuICAyICAuXG4gICAxICAyICA0ICAgIC4gIDIgIC4gICAgMSAgMiAgNCAgICAuICAyICAuXG4gICAuICAuICAuICAgIC4gIDIgIC4gICAgLiAgLiAgNCAgICAxICAyICAuXG4gICAgMHgwNzEgICAgICAweDIyNiAgICAgIDB4NDcwICAgICAgMHgzMjJcblxuICAgLiAgLiAgNCAgICAuICAyICAuICAgIC4gIC4gIC4gICAgMSAgMiAgLlxuICAgMSAgMiAgNCAgICAuICAyICAuICAgIDEgIDIgIDQgICAgLiAgMiAgLlxuICAgLiAgLiAgLiAgICAuICAyICA0ICAgIDEgIC4gIC4gICAgLiAgMiAgLlxuICAgIDB4MDc0ICAgICAgMHg2MjIgICAgICAweDE3MCAgICAgIDB4MjIzXG5cbiAgIDEgIDJcbiAgIDEgIDJcbiAgIDB4MzNcblxuICAgLiAgMiAgNCAgICAuICAyICAuICAgIC4gIC4gIC4gICAgMSAgLiAgLlxuICAgMSAgMiAgLiAgICAuICAyICA0ICAgIC4gIDIgIDQgICAgMSAgMiAgLlxuICAgLiAgLiAgLiAgICAuICAuICA0ICAgIDEgIDIgIC4gICAgLiAgMiAgLlxuICAgLiAgLiAgLiAgICAuICAuICAuICAgIC4gIC4gIC4gICAgLiAgLiAgLlxuICAgIDB4MDM2ICAgICAgMHg0NjIgICAgICAweDM2MCAgICAgIDB4MjMxXG5cbiAgIC4gIDIgIC4gICAgLiAgMiAgLiAgICAuICAuICAuICAgIC4gIDIgIC5cbiAgIDEgIDIgIDQgICAgLiAgMiAgNCAgICAxICAyICA0ICAgIDEgIDIgIC5cbiAgIC4gIC4gIC4gICAgLiAgMiAgLiAgICAuICAyICAuICAgIC4gIDIgIC5cbiAgICAweDA3MiAgICAgIDB4MjYyICAgICAgMHgyNzAgICAgICAweDIzMlxuXG4gICAxICAyICAuICAgIC4gIC4gIDQgICAgLiAgLiAgLiAgICAuICAyICAuXG4gICAuICAyICA0ICAgIC4gIDIgIDQgICAgMSAgMiAgLiAgICAxICAyICAuXG4gICAuICAuICAuICAgIC4gIDIgIC4gICAgLiAgMiAgNCAgICAxICAuICAuXG4gICAgMHgwNjMgICAgICAweDI2NCAgICAgIDB4NjMwICAgICAgMHgxMzIgICovXG5jb25zdCBFTkNPREVEX0JMT0NLUyA9IFtcbiAgWycwMGYwJywgJzQ0NDQnLCAnMGYwMCcsICcyMjIyJ10sXG4gIFsnMDcxJywgJzIyNicsICc0NzAnLCAnMzIyJ10sXG4gIFsnMDc0JywgJzYyMicsICcxNzAnLCAnMjIzJ10sXG4gIFsnMzMnXSxcbiAgWycwMzYnLCAnNDYyJywgJzM2MCcsICcyMzEnXSxcbiAgWycwNzInLCAnMjYyJywgJzI3MCcsICcyMzInXSxcbiAgWycwNjMnLCAnMjY0JywgJzYzMCcsICcxMzInXSxcbl07XG5cbmNvbnN0IEJMT0NLUyA9IEVOQ09ERURfQkxPQ0tTLm1hcCgoZW5jb2RlZEJsb2NrcywgaW5kZXgpID0+IChcbiAgZW5jb2RlZEJsb2Nrcy5tYXAoZW5jb2RlZEJsb2NrID0+IHtcbiAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICBsZXQgcm93O1xuXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBlbmNvZGVkQmxvY2subGVuZ3RoOyB5KyspIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICAgIHJvdyA9IChwYXJzZUludChlbmNvZGVkQmxvY2ssIDE2KSA+PiAoeSAqIDQpKVxuICAgICAgICAmIChNYXRoLnBvdygyLCBlbmNvZGVkQmxvY2subGVuZ3RoKSAtIDEpO1xuICAgICAgYmxvY2tzW3ldID0gW107XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGVuY29kZWRCbG9jay5sZW5ndGg7IHgrKykge1xuICAgICAgICBibG9ja3NbeV1beF0gPSByb3cgJiBNYXRoLnBvdygyLCB4KSA/IGluZGV4ICsgMSA6IDA7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbiAgICB9XG4gICAgcmV0dXJuIGJsb2NrcztcbiAgfSlcbikpO1xuXG5leHBvcnQgY29uc3QgU0hBUEVTID0gJ2lqbG9zdHonLnNwbGl0KCcnKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV0cmltaW5vIGV4dGVuZHMgQ2h1bmsge1xuICBjb25zdHJ1Y3Rvcih7IHJvdGF0aW9uID0gMCwgc2hhcGUsIHgsIHkgfSkge1xuICAgIHN1cGVyKHsgYmxvY2tzOiBCTE9DS1NbU0hBUEVTLmluZGV4T2Yoc2hhcGUpXVtyb3RhdGlvbl0sIHgsIHkgfSk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgfVxuXG4gIG1vdmUoW2R4LCBkeV0pIHtcbiAgICByZXR1cm4gbmV3IFRldHJpbWlubyh7IC4uLnRoaXMsIHg6IHRoaXMueCArIGR4LCB5OiB0aGlzLnkgKyBkeSB9KTtcbiAgfVxuXG4gIG1vdmVUbyhbeCwgeV0pIHtcbiAgICByZXR1cm4gbmV3IFRldHJpbWlubyh7IC4uLnRoaXMsIHgsIHkgfSk7XG4gIH1cblxuICByb3RhdGUoZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSAodGhpcy5yb3RhdGlvbiArIGRpcmVjdGlvbiAlIDQgKyA0KSAlIDQ7XG5cbiAgICByZXR1cm4gbmV3IFRldHJpbWlubyh7XG4gICAgICAuLi50aGlzLFxuICAgICAgYmxvY2tzOiBCTE9DS1NbU0hBUEVTLmluZGV4T2YodGhpcy5zaGFwZSldW3JvdGF0aW9uXSxcbiAgICAgIHJvdGF0aW9uLFxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgYXV0b2JpbmQgZnJvbSAnYXV0b2JpbmQtZGVjb3JhdG9yJztcbmltcG9ydCBDaHVuayBmcm9tICdtb2RlbHMvY2h1bmsnO1xuaW1wb3J0IERJUkVDVElPTiBmcm9tICdlbnVtcy9kaXJlY3Rpb24nO1xuaW1wb3J0IFRldHJpbWlubywgeyBTSEFQRVMgfSBmcm9tICdtb2RlbHMvdGV0cmltaW5vJztcblxuY29uc3QgSV9XQUxMX0tJQ0tTX1RBQkxFID0gW1xuICBbWzAsIDBdLCBbLTIsIDBdLCBbMSwgMF0sIFstMiwgLTFdLCBbMSwgMl1dLFxuICBbWzAsIDBdLCBbLTEsIDBdLCBbMiwgMF0sIFstMSwgMl0sIFsyLCAtMV1dLFxuICBbWzAsIDBdLCBbMiwgMF0sIFstMSwgMF0sIFsyLCAxXSwgWy0xLCAtMl1dLFxuICBbWzAsIDBdLCBbMSwgMF0sIFstMiwgMF0sIFsxLCAtMl0sIFstMiwgMV1dLFxuXTtcblxuY29uc3QgSkxTVFpfV0FMTF9LSUNLU19UQUJMRSA9IFtcbiAgW1swLCAwXSwgWy0xLCAwXSwgWy0xLCAxXSwgWzAsIC0yXSwgWy0xLCAtMl1dLFxuICBbWzAsIDBdLCBbMSwgMF0sIFsxLCAtMV0sIFswLCAyXSwgWzEsIDJdXSxcbiAgW1swLCAwXSwgWzEsIDBdLCBbMSwgMV0sIFswLCAtMl0sIFsxLCAtMl1dLFxuICBbWzAsIDBdLCBbLTEsIDBdLCBbLTEsIC0xXSwgWzAsIDJdLCBbLTEsIDJdXSxcbl07XG5cbmNvbnN0IGNyZWF0ZVJhbmRvbVRldHJpbWlubyA9ICgpID0+IG5ldyBUZXRyaW1pbm8oe1xuICBzaGFwZTogU0hBUEVTW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFNIQVBFUy5sZW5ndGgpXSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGZ1bGxSb3dzSW5kZXhlcyA9IFtdLFxuICAgIGhlaWdodCA9IDIwLFxuICAgIGxvY2tlZEJsb2NrcyxcbiAgICBxdWV1ZSxcbiAgICBxdWV1ZVNpemUgPSAzLFxuICAgIHRldHJpbWlubyxcbiAgICB3aWR0aCA9IDEwLFxuICB9ID0ge30pIHtcbiAgICB0aGlzLmZ1bGxSb3dzSW5kZXhlcyA9IGZ1bGxSb3dzSW5kZXhlcztcbiAgICB0aGlzLmdyYXZpdHkgPSAxIC8gNDA7IC8vIGNlbGxzIHBlciBmcmFtZSBhdCA2MCBmcHMgKGNlbGxzIHBlciBzZWNvbmQpXG4gICAgdGhpcy5oZWlnaHQgPSBsb2NrZWRCbG9ja3MgPyBsb2NrZWRCbG9ja3MubGVuZ3RoIDogaGVpZ2h0O1xuICAgIHRoaXMud2lkdGggPSBsb2NrZWRCbG9ja3MgPyBsb2NrZWRCbG9ja3NbMF0ubGVuZ3RoIDogd2lkdGg7XG4gICAgdGhpcy5sb2NrZWRCbG9ja3MgPSBsb2NrZWRCbG9ja3NcbiAgICAgIHx8IFsuLi5uZXcgQXJyYXkoaGVpZ2h0KV0ubWFwKCgpID0+IFsuLi5uZXcgQXJyYXkod2lkdGgpXS5maWxsKDApKTtcbiAgICB0aGlzLnF1ZXVlID0gcXVldWUgPz8gWy4uLkFycmF5KHF1ZXVlU2l6ZSldLm1hcChjcmVhdGVSYW5kb21UZXRyaW1pbm8pO1xuICAgIHRoaXMudGV0cmltaW5vID0gdGV0cmltaW5vO1xuICB9XG5cbiAgZ2V0IGdob3N0KCkge1xuICAgIGlmICghdGhpcy50ZXRyaW1pbm8pIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmhhcmREcm9wQ2h1bmsodGhpcy50ZXRyaW1pbm8pO1xuICB9XG5cbiAgZHJvcExvY2tlZEJsb2NrcygpIHtcbiAgICBjb25zdCBmdWxsUm93c0luZGV4ZXMgPSB0aGlzLmZ1bGxSb3dzSW5kZXhlcy5zbGljZSgpO1xuICAgIGxldCBnYW1lID0gdGhpcztcbiAgICBsZXQgZW5kO1xuXG4gICAgd2hpbGUgKChlbmQgPSBmdWxsUm93c0luZGV4ZXMuc2hpZnQoKSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZnVsbFJvd3NJbmRleGVzWzBdIHx8IDA7XG5cbiAgICAgIGdhbWUgPSBnYW1lLmV4dHJhY3RDaHVua3Moc3RhcnQsIGVuZClcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAubWFwKGdhbWUuaGFyZERyb3BDaHVuaylcbiAgICAgICAgLnJlZHVjZSgoc3RhdGUsIGNodW5rKSA9PiBzdGF0ZS5sb2NrQ2h1bmsoY2h1bmspLCBnYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHYW1lKHsgLi4uZ2FtZSwgZnVsbFJvd3NJbmRleGVzIH0pO1xuICB9XG5cbiAgZW1wdHlGdWxsUm93cygpIHtcbiAgICBjb25zdCBsb2NrZWRCbG9ja3MgPSB0aGlzLmxvY2tlZEJsb2Nrcy5zbGljZSgpO1xuXG4gICAgcmV0dXJuIG5ldyBHYW1lKHtcbiAgICAgIC4uLnRoaXMsXG4gICAgICBsb2NrZWRCbG9ja3M6IGxvY2tlZEJsb2Nrcy5tYXAoKHJvdywgaW5kZXgpID0+IChcbiAgICAgICAgdGhpcy5mdWxsUm93c0luZGV4ZXMuaW5jbHVkZXMoaW5kZXgpID8gQXJyYXkodGhpcy53aWR0aCkuZmlsbCgwKSA6IHJvd1xuICAgICAgKSksXG4gICAgfSk7XG4gIH1cblxuICBleHRyYWN0Q2h1bmtzKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICBsZXQgY2h1bms7XG5cbiAgICBmb3IgKGxldCB5ID0gc3RhcnQ7IHkgPCBlbmQ7IHkrKykge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSh4LCB5KSkgY29udGludWU7XG5cbiAgICAgICAgY2h1bmsgPSBjaHVua3MuZmluZChjaGsgPT4gKFxuICAgICAgICAgIGNoay5pbmNsdWRlcyhgJHt4fSwke3l9YCkgfHwgY2hrLmluY2x1ZGVzKGAke3ggKyAxfSwke3l9YClcbiAgICAgICAgKSk7XG4gICAgICAgIGlmICghY2h1bmspIHtcbiAgICAgICAgICBjaHVua3MucHVzaChbXSk7XG4gICAgICAgICAgY2h1bmsgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc0VtcHR5KHggKyAxLCB5KSAmJiAhY2h1bmsuaW5jbHVkZXMoYCR7eCArIDF9LCR7eX1gKSkge1xuICAgICAgICAgIGNodW5rLnB1c2goYCR7eCArIDF9LCR7eX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNFbXB0eSh4LCB5ICsgMSkgJiYgIWNodW5rLmluY2x1ZGVzKGAke3h9LCR7eSArIDF9YCkpIHtcbiAgICAgICAgICBjaHVuay5wdXNoKGAke3h9LCR7eSArIDF9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaHVuay5pbmNsdWRlcyhgJHt4fSwke3l9YCkpIGNodW5rLnB1c2goYCR7eH0sJHt5fWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2h1bmtzLm1hcChzdHJpbmdzID0+IHtcbiAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gc3RyaW5ncy5tYXAoc3RyaW5nID0+IHN0cmluZy5zcGxpdCgnLCcpKTtcbiAgICAgIGNvbnN0IHhNYXggPSBNYXRoLm1heCguLi5jb29yZGluYXRlcy5tYXAoKFt4XSkgPT4geCkpO1xuICAgICAgY29uc3QgeE1pbiA9IE1hdGgubWluKC4uLmNvb3JkaW5hdGVzLm1hcCgoW3hdKSA9PiB4KSk7XG4gICAgICBjb25zdCB5TWF4ID0gTWF0aC5tYXgoLi4uY29vcmRpbmF0ZXMubWFwKChbLCB5XSkgPT4geSkpO1xuICAgICAgY29uc3QgeU1pbiA9IE1hdGgubWluKC4uLmNvb3JkaW5hdGVzLm1hcCgoWywgeV0pID0+IHkpKTtcbiAgICAgIGNvbnN0IGJsb2NrcyA9IFsuLi5BcnJheSh5TWF4IC0geU1pbiArIDEpXVxuICAgICAgICAubWFwKCgpID0+IEFycmF5KHhNYXggLSB4TWluICsgMSkuZmlsbCgwKSk7XG5cbiAgICAgIGNvb3JkaW5hdGVzLmZvckVhY2goKFt4LCB5XSkgPT4ge1xuICAgICAgICBibG9ja3NbeSAtIHlNaW5dW3ggLSB4TWluXSA9IHRoaXMubG9ja2VkQmxvY2tzW3ldW3hdO1xuICAgICAgICB0aGlzLmxvY2tlZEJsb2Nrc1t5XVt4XSA9IDA7IC8vIEB0b2RvOiBkbyBub3QgbXV0YXRlIGxvY2tlZEJsb2Nrc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IENodW5rKHsgYmxvY2tzLCB4OiB4TWluLCB5OiB5TWluIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgQGF1dG9iaW5kXG4gIGhhcmREcm9wQ2h1bmsoY2h1bmspIHtcbiAgICBsZXQgbmV4dCA9IGNodW5rO1xuXG4gICAgd2hpbGUgKHRoaXMuaXNWYWxpZENodW5rKG5leHQubW92ZShESVJFQ1RJT04uRE9XTikpKSB7XG4gICAgICBuZXh0ID0gbmV4dC5tb3ZlKERJUkVDVElPTi5ET1dOKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBoYXJkRHJvcFRldHJpbWlubygpIHtcbiAgICByZXR1cm4gbmV3IEdhbWUoeyAuLi50aGlzLCB0ZXRyaW1pbm86IHRoaXMuZ2hvc3QgfSk7XG4gIH1cblxuICBpc0VtcHR5KHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NrZWRCbG9ja3NbeV0gJiYgIXRoaXMubG9ja2VkQmxvY2tzW3ldW3hdO1xuICB9XG5cbiAgaXNPdXRPZkJvdW5kcyh4LCB5KSB7XG4gICAgcmV0dXJuIHggPCAwIHx8IHggPj0gdGhpcy53aWR0aCB8fCB5IDwgMCB8fCB5ID49IHRoaXMuaGVpZ2h0O1xuICB9XG5cbiAgaXNWYWxpZENodW5rKGNodW5rKSB7XG4gICAgcmV0dXJuIGNodW5rLmJsb2Nrcy5ldmVyeSgocm93LCB5KSA9PiAoXG4gICAgICByb3cuZXZlcnkoKGJsb2NrLCB4KSA9PiAoXG4gICAgICAgICFjaHVuay5ibG9ja3NbeV1beF1cbiAgICAgICAgICB8fCAodGhpcy5pc0VtcHR5KGNodW5rLnggKyB4LCBjaHVuay55ICsgeSlcbiAgICAgICAgICAgICYmICF0aGlzLmlzT3V0T2ZCb3VuZHMoY2h1bmsueCArIHgsIGNodW5rLnkgKyB5KSlcbiAgICAgICkpXG4gICAgKSk7XG4gIH1cblxuICBsb2NrQ2h1bmsoY2h1bmspIHtcbiAgICBjb25zdCBsb2NrZWRCbG9ja3MgPSB0aGlzLmxvY2tlZEJsb2Nrcy5zbGljZSgpO1xuXG4gICAgY2h1bmsuYmxvY2tzLmZvckVhY2goKHJvdywgeSkgPT4gcm93LmZvckVhY2goKGJsb2NrLCB4KSA9PiB7XG4gICAgICBpZiAoIWJsb2NrKSByZXR1cm47XG4gICAgICBsb2NrZWRCbG9ja3NbY2h1bmsueSArIHldW2NodW5rLnggKyB4XSA9IGJsb2NrO1xuICAgIH0pKTtcbiAgICByZXR1cm4gbmV3IEdhbWUoeyAuLi50aGlzLCBsb2NrZWRCbG9ja3MgfSk7XG4gIH1cblxuICBsb2NrVGV0cmltaW5vKCkge1xuICAgIHJldHVybiBuZXcgR2FtZSh7XG4gICAgICAuLi50aGlzLmxvY2tDaHVuayh0aGlzLnRldHJpbWlubyksXG4gICAgICB0ZXRyaW1pbm86IG51bGwsXG4gICAgfSk7XG4gIH1cblxuICBtYXJrRnVsbFJvd3MoKSB7XG4gICAgcmV0dXJuIG5ldyBHYW1lKHtcbiAgICAgIC4uLnRoaXMsXG4gICAgICBmdWxsUm93c0luZGV4ZXM6IHRoaXMubG9ja2VkQmxvY2tzXG4gICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgKGZ1bGxSb3dzLCByb3csIGluZGV4KSA9PiAoXG4gICAgICAgICAgICByb3cuZXZlcnkoYmxvY2sgPT4gYmxvY2spID8gZnVsbFJvd3MuY29uY2F0KGluZGV4KSA6IGZ1bGxSb3dzXG4gICAgICAgICAgKSxcbiAgICAgICAgICBbXSxcbiAgICAgICAgKVxuICAgICAgICAucmV2ZXJzZSgpLFxuICAgIH0pO1xuICB9XG5cbiAgbW92ZVRldHJpbWlubyhbeCwgeV0pIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy50ZXRyaW1pbm8ubW92ZShbeCwgeV0pO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRDaHVuayhuZXh0KSkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIG5ldyBHYW1lKHsgLi4udGhpcywgdGV0cmltaW5vOiBuZXh0IH0pO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgcmV0dXJuIG5ldyBHYW1lKHsgaGVpZ2h0OiB0aGlzLmhlaWdodCwgd2lkdGg6IHRoaXMud2lkdGggfSk7XG4gIH1cblxuICByb3RhdGVUZXRyaW1pbm8oYW5nbGUpIHtcbiAgICBpZiAodGhpcy50ZXRyaW1pbm8uc2hhcGUgPT09ICdvJykgcmV0dXJuIHRoaXM7XG5cbiAgICBsZXQgbmV4dCA9IHRoaXMudGV0cmltaW5vO1xuICAgIGNvbnN0IGluZGV4ID0gYW5nbGUgPT09IERJUkVDVElPTi5DTE9DS1dJU0VcbiAgICAgID8gbmV4dC5yb3RhdGlvblxuICAgICAgOiBuZXh0LnJvdGF0ZShhbmdsZSkucm90YXRpb247XG4gICAgY29uc3Qgd2FsbEtpY2tzID0gbmV4dC5zaGFwZSA9PT0gJ2knXG4gICAgICA/IElfV0FMTF9LSUNLU19UQUJMRVtpbmRleF1cbiAgICAgIDogSkxTVFpfV0FMTF9LSUNLU19UQUJMRVtpbmRleF07XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgW3gsIHldID0gd2FsbEtpY2tzW2ldO1xuICAgICAgbmV4dCA9IHRoaXMudGV0cmltaW5vLnJvdGF0ZShhbmdsZSkubW92ZShbeCAqIGFuZ2xlLCB5ICogYW5nbGVdKTtcbiAgICB9IHdoaWxlICghdGhpcy5pc1ZhbGlkQ2h1bmsobmV4dCkgJiYgd2FsbEtpY2tzWysraV0pO1xuICAgIHJldHVybiBpIDwgd2FsbEtpY2tzLmxlbmd0aFxuICAgICAgPyBuZXcgR2FtZSh7IC4uLnRoaXMsIHRldHJpbWlubzogbmV4dCB9KVxuICAgICAgOiB0aGlzO1xuICB9XG5cbiAgc2hpZnRRdWV1ZSgpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWUuc2xpY2UoKTtcblxuICAgIHF1ZXVlLnB1c2goY3JlYXRlUmFuZG9tVGV0cmltaW5vKCkpO1xuXG4gICAgbGV0IHRldHJpbWlubyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgdGV0cmltaW5vID0gdGV0cmltaW5vLm1vdmVUbyhbXG4gICAgICBNYXRoLmZsb29yKCh0aGlzLndpZHRoIC0gdGV0cmltaW5vLmJsb2Nrcy5sZW5ndGgpIC8gMiksXG4gICAgICAwLFxuICAgIF0pO1xuICAgIHJldHVybiBuZXcgR2FtZSh7IC4uLnRoaXMsIHF1ZXVlLCB0ZXRyaW1pbm8gfSk7XG4gIH1cbn1cbiIsImltcG9ydCBhdXRvYmluZCBmcm9tICdhdXRvYmluZC1kZWNvcmF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dHNIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoZG9tTm9kZSkge1xuICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgZG9tTm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgdGhpcy5pbnB1dHMucHVzaChldmVudC5jb2RlKTtcbiAgfVxuXG4gIHJlYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzLnNoaWZ0KCk7XG4gIH1cbn1cbiIsIi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2NvZGVcbmV4cG9ydCBkZWZhdWx0IHtcbiAgQTogJ0tleUEnLFxuICBDVFJMX0xFRlQ6ICdDb250cm9sTGVmdCcsXG4gIENUUkxfUklHSFQ6ICdDb250cm9sUmlnaHQnLFxuICBEOiAnS2V5RCcsXG4gIERPV05fQVJST1c6ICdBcnJvd0Rvd24nLFxuICBFTlRFUjogJ0VudGVyJyxcbiAgRVNDQVBFOiAnRXNjYXBlJyxcbiAgRjE6ICdGMScsXG4gIExFRlRfQVJST1c6ICdBcnJvd0xlZnQnLFxuICBSSUdIVF9BUlJPVzogJ0Fycm93UmlnaHQnLFxuICBTOiAnS2V5UycsXG4gIFNQQUNFOiAnU3BhY2UnLFxuICBVUF9BUlJPVzogJ0Fycm93VXAnLFxuICBYOiAnS2V5WCcsXG4gIFo6ICdLZXlaJyxcbn07XG4iLCJpbXBvcnQgR3Jhdml0eVN0YXRlIGZyb20gJ21vZGVscy9zdGF0ZXMvZ3Jhdml0eSc7XG5pbXBvcnQga2V5IGZyb20gJ2VudW1zL2tleSc7XG5pbXBvcnQgU3RhdGUgZnJvbSAnZW51bXMvc3RhdGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXVzZWRTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKHsgZ2FtZSB9KSB7XG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcbiAgICB0aGlzLm5hbWUgPSBTdGF0ZS5QQVVTRUQ7XG4gIH1cblxuICBwcm9jZXNzSW5wdXQoaW5wdXQpIHtcbiAgICBzd2l0Y2ggKGlucHV0KSB7XG4gICAgY2FzZSBrZXkuRVNDQVBFOlxuICAgIGNhc2Uga2V5LkYxOlxuICAgICAgcmV0dXJuIG5ldyBHcmF2aXR5U3RhdGUoe1xuICAgICAgICAuLi50aGlzLFxuICAgICAgICBsYXN0VXBkYXRlZEF0OiB0aGlzLnRpbWVzdGFtcCxcbiAgICAgICAgc3RhcnRlZEF0OiB0aGlzLnRpbWVzdGFtcCxcbiAgICAgIH0pO1xuXG4gICAgZGVmYXVsdDogcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCJpbXBvcnQgR3Jhdml0eVN0YXRlIGZyb20gJ21vZGVscy9zdGF0ZXMvZ3Jhdml0eSc7XG5cbmNvbnN0IENMRUFSX0RVUkFUSU9OID0gNTAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3dzQ2xlYXJpbmdTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKHsgZ2FtZSwgc3RhcnRzQXQgPSAwIH0pIHtcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xuICAgIHRoaXMuc3RhcnRzQXQgPSBzdGFydHNBdDtcbiAgfVxuXG4gIHByb2Nlc3NJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVwZGF0ZSh0aW1lc3RhbXApIHtcbiAgICBsZXQgeyBnYW1lIH0gPSB0aGlzO1xuXG4gICAgZ2FtZSA9IGdhbWUubWFya0Z1bGxSb3dzKCk7XG4gICAgaWYgKGdhbWUuZnVsbFJvd3NJbmRleGVzLmxlbmd0aCkge1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0c0F0KSB7XG4gICAgICAgIHRoaXMuc3RhcnRzQXQgPSB0aW1lc3RhbXA7XG4gICAgICAgIHJldHVybiBuZXcgUm93c0NsZWFyaW5nU3RhdGUoeyAuLi50aGlzLCBnYW1lIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzdGFtcCA8IHRoaXMuc3RhcnRzQXQgKyBDTEVBUl9EVVJBVElPTikgcmV0dXJuIHRoaXM7XG4gICAgICBnYW1lID0gZ2FtZS5lbXB0eUZ1bGxSb3dzKCkuZHJvcExvY2tlZEJsb2NrcygpO1xuICAgICAgcmV0dXJuIG5ldyBSb3dzQ2xlYXJpbmdTdGF0ZSh7IGdhbWUgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgR3Jhdml0eVN0YXRlKHsgLi4udGhpcywgZ2FtZSB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IERJUkVDVElPTiBmcm9tICdlbnVtcy9kaXJlY3Rpb24nO1xuaW1wb3J0IGtleSBmcm9tICdlbnVtcy9rZXknO1xuaW1wb3J0IE5ld0dhbWVTdGF0ZSBmcm9tICdtb2RlbHMvc3RhdGVzL25ldy1nYW1lJztcbmltcG9ydCBQYXVzZWRTdGF0ZSBmcm9tICdtb2RlbHMvc3RhdGVzL3BhdXNlZCc7XG5pbXBvcnQgUm93c0NsZWFyaW5nU3RhdGUgZnJvbSAnbW9kZWxzL3N0YXRlcy9yb3dzLWNsZWFyaW5nJztcbmltcG9ydCBTdGF0ZSBmcm9tICdlbnVtcy9zdGF0ZSc7XG5cbmNvbnN0IEZSQU1FX0xFTkdUSF9BVF82MF9GUFMgPSAxMDAwIC8gNjA7XG5jb25zdCBMT0NLX0RFTEFZID0gNTAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmF2aXR5U3RhdGUge1xuICBjb25zdHJ1Y3Rvcih7IGdhbWUsIGxhc3RVcGRhdGVkQXQsIGxvY2tFeHBpcnksIG1vdmVzTGVmdCwgc3RhcnRlZEF0IH0pIHtcbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xuICAgIHRoaXMubGFzdFVwZGF0ZWRBdCA9IGxhc3RVcGRhdGVkQXQgfHwgMDtcbiAgICB0aGlzLmxvY2tFeHBpcnkgPSBsb2NrRXhwaXJ5IHx8IDA7XG4gICAgdGhpcy5tb3Zlc0xlZnQgPSBtb3Zlc0xlZnQgfHwgMDtcbiAgICB0aGlzLm5hbWUgPSBTdGF0ZS5HUkFWSVRZO1xuICAgIHRoaXMuc3RhcnRlZEF0ID0gc3RhcnRlZEF0IHx8IDA7XG4gIH1cblxuICBhcHBseUdyYXZpdHkoZ2FtZSkge1xuICAgIGNvbnN0IHsgbGFzdFVwZGF0ZWRBdCwgc3RhcnRlZEF0LCB0aW1lc3RhbXAgfSA9IHRoaXM7XG4gICAgY29uc3QgZHQgPSB0aW1lc3RhbXAgLSBzdGFydGVkQXQgLSBsYXN0VXBkYXRlZEF0O1xuICAgIGNvbnN0IGR5ID0gTWF0aC5mbG9vcihkdCAqIGdhbWUuZ3Jhdml0eSAvIEZSQU1FX0xFTkdUSF9BVF82MF9GUFMpO1xuXG4gICAgaWYgKGR5KSB0aGlzLmxhc3RVcGRhdGVkQXQgPSB0aW1lc3RhbXAgLSBzdGFydGVkQXQ7XG4gICAgcmV0dXJuIGdhbWUubW92ZVRldHJpbWlubyhbMCwgZHldKTtcbiAgfVxuXG4gIGhhcmREcm9wVGV0cmltaW5vKCkge1xuICAgIGNvbnN0IHsgZ2FtZSB9ID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUm93c0NsZWFyaW5nU3RhdGUoe1xuICAgICAgLi4udGhpcyxcbiAgICAgIGdhbWU6IGdhbWUuaGFyZERyb3BUZXRyaW1pbm8oKS5sb2NrVGV0cmltaW5vKCksXG4gICAgfSk7XG4gIH1cblxuICBtb3ZlVGV0cmltaW5vKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgZ2FtZSwgbG9ja0V4cGlyeSwgdGltZXN0YW1wIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5leHQgPSBnYW1lLm1vdmVUZXRyaW1pbm8oZGlyZWN0aW9uKTtcblxuICAgIGlmIChuZXh0ID09PSBnYW1lKSByZXR1cm4gdGhpcztcbiAgICBpZiAobG9ja0V4cGlyeSkge1xuICAgICAgdGhpcy5sb2NrRXhwaXJ5ID0gdGltZXN0YW1wICsgTE9DS19ERUxBWTtcbiAgICAgIC0tdGhpcy5tb3Zlc0xlZnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgR3Jhdml0eVN0YXRlKHsgLi4udGhpcywgZ2FtZTogbmV4dCB9KTtcbiAgfVxuXG4gIHByb2Nlc3NJbnB1dChpbnB1dCkge1xuICAgIGlmICghdGhpcy5nYW1lLnRldHJpbWlubykgcmV0dXJuIHRoaXM7XG5cbiAgICBzd2l0Y2ggKGlucHV0KSB7XG4gICAgY2FzZSBrZXkuQ1RSTF9MRUZUOlxuICAgIGNhc2Uga2V5LkNUUkxfUklHSFQ6XG4gICAgY2FzZSBrZXkuWjpcbiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZVRldHJpbWlubyhESVJFQ1RJT04uQ09VTlRFUkNMT0NLV0lTRSk7XG5cbiAgICBjYXNlIGtleS5ET1dOX0FSUk9XOlxuICAgIGNhc2Uga2V5LlM6XG4gICAgICByZXR1cm4gdGhpcy5tb3ZlVGV0cmltaW5vKERJUkVDVElPTi5ET1dOKTtcblxuICAgIGNhc2Uga2V5LkVTQ0FQRTpcbiAgICBjYXNlIGtleS5GMTpcbiAgICAgIHJldHVybiBuZXcgUGF1c2VkU3RhdGUodGhpcyk7XG5cbiAgICBjYXNlIGtleS5MRUZUX0FSUk9XOlxuICAgIGNhc2Uga2V5LkE6XG4gICAgICByZXR1cm4gdGhpcy5tb3ZlVGV0cmltaW5vKERJUkVDVElPTi5MRUZUKTtcblxuICAgIGNhc2Uga2V5LlJJR0hUX0FSUk9XOlxuICAgIGNhc2Uga2V5LkQ6XG4gICAgICByZXR1cm4gdGhpcy5tb3ZlVGV0cmltaW5vKERJUkVDVElPTi5SSUdIVCk7XG5cbiAgICBjYXNlIGtleS5TUEFDRTpcbiAgICAgIHJldHVybiB0aGlzLmhhcmREcm9wVGV0cmltaW5vKCk7XG5cbiAgICBjYXNlIGtleS5VUF9BUlJPVzpcbiAgICBjYXNlIGtleS5YOlxuICAgICAgcmV0dXJuIHRoaXMucm90YXRlVGV0cmltaW5vKERJUkVDVElPTi5DTE9DS1dJU0UpO1xuXG4gICAgZGVmYXVsdDogcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgcm90YXRlVGV0cmltaW5vKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgZ2FtZSwgbG9ja0V4cGlyeSwgdGltZXN0YW1wIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5leHQgPSBnYW1lLnJvdGF0ZVRldHJpbWlubyhkaXJlY3Rpb24pO1xuXG4gICAgaWYgKG5leHQgPT09IHRoaXMuZ2FtZSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKGxvY2tFeHBpcnkpIHtcbiAgICAgIHRoaXMubG9ja0V4cGlyeSA9IHRpbWVzdGFtcCArIExPQ0tfREVMQVk7XG4gICAgICAtLXRoaXMubW92ZXNMZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEdyYXZpdHlTdGF0ZSh7IC4uLnRoaXMsIGdhbWU6IG5leHQgfSk7XG4gIH1cblxuICB1cGRhdGUodGltZXN0YW1wKSB7XG4gICAgbGV0IHsgZ2FtZSB9ID0gdGhpcztcblxuICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIGlmICghdGhpcy5zdGFydGVkQXQpIHRoaXMuc3RhcnRlZEF0ID0gdGltZXN0YW1wO1xuXG4gICAgaWYgKCFnYW1lLnRldHJpbWlubykgZ2FtZSA9IGdhbWUuc2hpZnRRdWV1ZSgpO1xuICAgIGlmICghZ2FtZS5pc1ZhbGlkQ2h1bmsoZ2FtZS50ZXRyaW1pbm8pKSB7XG4gICAgICByZXR1cm4gbmV3IE5ld0dhbWVTdGF0ZSh7IGdhbWU6IGdhbWUucmVzZXQoKSB9KTtcbiAgICB9XG5cbiAgICBnYW1lID0gdGhpcy5hcHBseUdyYXZpdHkoZ2FtZSk7XG4gICAgaWYgKGdhbWUuaXNWYWxpZENodW5rKGdhbWUudGV0cmltaW5vLm1vdmUoRElSRUNUSU9OLkRPV04pKSkge1xuICAgICAgcmV0dXJuIG5ldyBHcmF2aXR5U3RhdGUoeyAuLi50aGlzLCBnYW1lLCBsb2NrRXhwaXJ5OiAwIH0pO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMubG9ja0V4cGlyeSkge1xuICAgICAgcmV0dXJuIG5ldyBHcmF2aXR5U3RhdGUoe1xuICAgICAgICAuLi50aGlzLFxuICAgICAgICBnYW1lLFxuICAgICAgICBsb2NrRXhwaXJ5OiB0aW1lc3RhbXAgKyBMT0NLX0RFTEFZLFxuICAgICAgICBtb3Zlc0xlZnQ6IDE1LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aW1lc3RhbXAgPiB0aGlzLmxvY2tFeHBpcnkgfHwgIXRoaXMubW92ZXNMZWZ0KSB7XG4gICAgICByZXR1cm4gbmV3IFJvd3NDbGVhcmluZ1N0YXRlKHtcbiAgICAgICAgLi4udGhpcyxcbiAgICAgICAgZ2FtZTogZ2FtZS5sb2NrVGV0cmltaW5vKCksXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsImltcG9ydCBHcmF2aXR5U3RhdGUgZnJvbSAnbW9kZWxzL3N0YXRlcy9ncmF2aXR5JztcbmltcG9ydCBLZXkgZnJvbSAnZW51bXMva2V5JztcbmltcG9ydCBTdGF0ZSBmcm9tICdlbnVtcy9zdGF0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5ld0dhbWVTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKHsgZ2FtZSB9KSB7XG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcbiAgICB0aGlzLm5hbWUgPSBTdGF0ZS5ORVdfR0FNRTtcbiAgfVxuXG4gIHByb2Nlc3NJbnB1dChpbnB1dCkge1xuICAgIHN3aXRjaCAoaW5wdXQpIHtcbiAgICBjYXNlIEtleS5FTlRFUjpcbiAgICAgIHJldHVybiBuZXcgR3Jhdml0eVN0YXRlKHRoaXMpO1xuXG4gICAgZGVmYXVsdDogcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCJpbXBvcnQgYXNjaWlSZW5kZXJlciBmcm9tICdtb2RlbHMvcmVuZGVyZXJzL2FzY2lpJztcbmltcG9ydCBDb3JlIGZyb20gJ21vZGVscy9jb3JlJztcbmltcG9ydCBHYW1lIGZyb20gJ21vZGVscy9nYW1lJztcbmltcG9ydCBJbnB1dHNIYW5kbGVyIGZyb20gJ21vZGVscy9pbnB1dHMtaGFuZGxlcic7XG5pbXBvcnQgTmV3R2FtZVN0YXRlIGZyb20gJ21vZGVscy9zdGF0ZXMvbmV3LWdhbWUnO1xuaW1wb3J0ICcuL3N0eWxlcy5zY3NzJztcblxuY29uc3QgaW5wdXRzSGFuZGxlciA9IG5ldyBJbnB1dHNIYW5kbGVyKGRvY3VtZW50LmJvZHkpO1xuY29uc3QgZ2FtZSA9IG5ldyBHYW1lKCk7XG5jb25zdCByZW5kZXJlciA9IGFzY2lpUmVuZGVyZXIoZ2FtZS53aWR0aCwgZ2FtZS5oZWlnaHQpO1xuY29uc3Qgc3RhdGUgPSBuZXcgTmV3R2FtZVN0YXRlKHsgZ2FtZSB9KTtcbmNvbnN0IGNvcmUgPSBuZXcgQ29yZSh7IGlucHV0c0hhbmRsZXIsIHJlbmRlcmVyLCBzdGF0ZSB9KTtcblxuY29yZS5sb29wKCk7XG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBS0E7QUFoQkE7QUFrQkE7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRkE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7OztBQVhBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7QUFVQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFJQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFIQTtBQUtBOzs7O0FBdkJBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQU1BO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBRkE7QUFNQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQU1BO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBckJBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFEQTtBQWlCQTtBQXRCQTtBQUNBO0FBR0E7QUFBQTtBQW1CQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBT0E7OztBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJQTtBQUFBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUVBO0FBRkE7QUFJQTs7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBREE7QUFKQTtBQVdBOzs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBOzs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBbkxBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBc0VBOzs7Ozs7Ozs7Ozs7O0FDcEhBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFQQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBOzs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQUE7QUFUQTtBQVdBOzs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUdBO0FBRUE7QUFGQTtBQUlBOzs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUE3QkE7QUErQkE7OztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFFQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSkE7QUFNQTs7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')}]);